#pragma checksum "C:\Users\Damian\Desktop\blogpost\Pages\Index.cshtml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "e22bf7b27a31dd725f695457d96ddadc62f54905"
// <auto-generated/>
#pragma warning disable 1591
[assembly: global::Microsoft.AspNetCore.Razor.Hosting.RazorCompiledItemAttribute(typeof(aplicacionASP.Pages.Pages_Index), @"mvc.1.0.razor-page", @"/Pages/Index.cshtml")]
[assembly:global::Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.RazorPageAttribute(@"/Pages/Index.cshtml", typeof(aplicacionASP.Pages.Pages_Index), null)]
namespace aplicacionASP.Pages
{
    #line hidden
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.AspNetCore.Mvc.Rendering;
    using Microsoft.AspNetCore.Mvc.ViewFeatures;
#line 1 "C:\Users\Damian\Desktop\blogpost\Pages\_ViewImports.cshtml"
using aplicacionASP;

#line default
#line hidden
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"e22bf7b27a31dd725f695457d96ddadc62f54905", @"/Pages/Index.cshtml")]
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"c17c9475b3f2470ab716b84fe96bf22a87969a9f", @"/Pages/_ViewImports.cshtml")]
    public class Pages_Index : global::Microsoft.AspNetCore.Mvc.RazorPages.Page
    {
        #pragma warning disable 1998
        public async override global::System.Threading.Tasks.Task ExecuteAsync()
        {
#line 3 "C:\Users\Damian\Desktop\blogpost\Pages\Index.cshtml"
  
    ViewData["Title"] = "Home page";

#line default
#line hidden
            BeginContext(71, 10052, true);
            WriteLiteral(@"
<!-- <div class=""text-center""> -->
<div class=""contenedor"" >
    <h3 class=""leftTextAlign"">Easiest way to get started - Your first .NET Core + Docker app</h3>
    <!-- <p>Learn about <a href=""https://docs.microsoft.com/aspnet/core"">building Web apps with ASP.NET Core</a>.</p> -->

    <p class=""leftTextAlign"">
        Hey everbody! Today we're going to see a simple way to make a web application with ASP.net using Docker containers. <br>
        <ul>                                                                                                                                            
            <li> Docker allows us to create standard packages that with all we need to make a web application work. Docker installs all the dependencies and services required for any operating system (OS). </li>
            <li> Also, Docker has become the most popular package system. All of the OS's manufacturers and suppliers are aware of their capabilities. </li>                                                   ");
            WriteLiteral(@"                                                                
            <li> With Docker you get consistency and you guarantee that the content placed in a container will run on any computer. If it works in development, it will work in production because with Docker they are the same. </li>
            <li> Docker doesn´t take up much memory and is more scalable than a virtual machine because it only uses the resources required at needs at any one time. </li>
            <li> Another advantage of Docker is that it can be used to unify the development environments and the workflow within them. You do not even have to install the working Software developers kits (SDKs) or compilers on your computer. </li>
            <li> With Docker you can define a work environment based on Docker images for all your work team (different OS) and with this, you can ensure that all members have the same version and everything will work the same file. </li>
            <li> Although Docker was created in, and for, Linu");
            WriteLiteral(@"x. Its use in .NET and Windows has not stopped growing and is improving its level of service. This is due to the Microsoft team who are working very closely with the Docker team and its developers community. </li>
        </ul>


        <h4> Now let's go to action! The ""Step by step guide"": </h4>

        As always we will show you the requirements needed. It´s necessary to have a text editor and have an operating system with an x64 or x86 architecture installed. <br>

        Well let's get started! <br>

        The first thing we are going to do is install .NET Core 2.1 SDK (or a higher version). To install it, click the following <a href=""https://dotnet.microsoft.com/download"">link</a>. <br>
        Imagen <br>

        In the meantime, go make yourself a coffee, the download will take one or two minutes. <br>

        To confirm that .NET Core has properly been installed type the following command: <br>

        $ dotnet <br>

        You should then see the instructions on how to use");
            WriteLiteral(@" .NET Core. If this doesn´t appear try commenting in <a href=""https://forums.dotnetfoundation.org/"">.NET </a> or <a href=""https://forums.asp.net/"">ASP</a> forums. <br>

        Then we need to create the directory where you can save the application. Return back to the console to write the following commands: <br>

        $ dotnet new webApp -o myWebApp --no-https <br>
        $ cd myWebApp <br>                                                                                                                                    

        What do these commands mean-let's break it down. <br> 
        <ul>
            <li> ""dotnet new"" creates a new application. </li>
            <li> The ""webApp"" parameter indicates what type or model of application is required. In this case we want a web application. </li>
            <li> ""-or"" creates a folder called myWebApp where your application will be saved. </li>
            <li> The specific ""non-https"" flag says that we don´t want to activate https. </li>
 ");
            WriteLiteral(@"           <li> Finally, the ""cd myWebApp"" command takes us to our new folder. </li>
        </ul>
        It's time to run the application! <br>


        In the console we need to write: <br>

        $ dotnet run <br>

        We now need to open the browser and in the address bar enter at http: // localhost: 5000. <br>
        The application is already working! (icono de celebracion). <br>
        If you want to edit your application you can learn to use Razor in the following link. Here you can change the format, colors and much more. <br>
    </p>
    
    <h3 class=""leftTextAlign"">Dockerize the .NET Core application</h3>

    <p class=""leftTextAlign"">
        Now that we have installed the web application we are going to use Docker simultaneously with .NET Core. <br>

        To begin with docker we have to download it from their page. Then, we need to create a new file a name it “Dockerfile” without any extension. <br>
        Within this file we need to write the following comman");
            WriteLiteral(@"ds. <br>

        FROM microsoft/dotnet:2.1-sdk <br>
        WORKDIR /app <br>

        # copy csproj and restore as distinct layers <br>
        COPY *.csproj ./ <br>
        RUN dotnet restore <br>

        # copy and build everything else <br>
        COPY . ./ <br>
        RUN dotnet publish -c Release -o out <br>
        ENTRYPOINT [""dotnet"", ""out/Hello.dll""] <br>
                                    
        This contains instructions on how to build these run one after each other. <br>

        The “FROM” instruction tells the computer to initiate a new build stage and creates the Base image for the following instructions. <br>

        The multi-arch tags pull either Windows or Linux containers depending on the Docker for Windows container mode. The Base Image for our sample is the 2.1-sdk image from the microsoft/dotnet repository, <br>
        

        FROM microsoft/dotnet:2.1-sdk <br>

        The WORKDIR instruction sets the working directory for any remaining RUN, CMD, ENT");
            WriteLiteral(@"RYPOINT, COPY, and ADD Dockerfile instructions. If the directory doesn't exist, it's created. In this case, WORKDIR is set to the app directory. <br>
        

        WORKDIR /app <br>

        The COPY instruction copies new files or directories from the source path and adds them to the destination container filesystem. With this instruction, we are copying the C# project file to the container. <br>
        

        COPY *.csproj ./ <br>

        The RUN instruction executes any commands in a new layer on top of the current image and commit the results. The resulting committed image is used for the next step in the Dockerfile. We are running dotnet restore to get the needed dependencies of the C# project file. <br>
        

        RUN dotnet restore <br>

        This COPY instruction copies the rest of the files into our container into new layers. <br>
        

        COPY . ./ <br>

        We are publishing the app with this RUN instruction. The dotnet publish command compiles th");
            WriteLiteral(@"e application, reads through its dependencies specified in the project file, and publishes the resulting set of files to a directory. Our app is published with a Release configuration and output to the default directory. <br>
        

        RUN dotnet publish -c Release -o out <br>

        The ENTRYPOINT instruction allows the container to run as an executable. <br>
        

        ENTRYPOINT [""dotnet"", ""out/Hello.dll""] <br>

        Now you have a Dockerfile that: <br>

        <ul>
            <li>     copies your app to the image </li>
            <li>     your app's dependencies to the image </li>
            <li> builds the app to run as an executable </li>
        </ul>
        Build and run the Hello .NET Core app <br>
        Essential Docker commands <br>

        These Docker commands are essential: <br>

            docker build <br>
            docker run <br>
            docker ps <br>
            docker stop <br>
            docker rm <br>
            docker rmi ");
            WriteLiteral(@"<br>
            docker image <br>
    </p>

    <h4 class=""leftTextAlign"" >  Build and run </h4>

    <p class=""leftTextAlign"">
        You wrote the dockerfile; now Docker builds your app and then runs the container. <br>
        console <br>

        docker build -t dotnetapp-dev . <br>
        docker run --rm dotnetapp-dev Hello from Docker <br>

        The output from the docker build command should be similar to the following console output: <br>
        console <br>
    IMAGEN DE FLECHITAS <br>

        As you can see from the output, the Docker Engine used the Dockerfile to build our container. <br>
        The output from the docker run command should be similar to the following console output: <br>

        “Hello World!” <br>
                    
        Congratulations! We have just: <br>
        <ul>                    
            <li> Created a local .NET Core app </li>
            <li> Created a Dockerfile to build your first container </li>
            <li> Built an");
            WriteLiteral(@"d ran your Dockerized app </li>
        </ul>
        So,  that was everything for today. Remember that we post a new blog every week. <br> 
        Please share our page with those who might be interested and leave us a comment below we are really keen to increase our community.  You can subscribe to our mailing list by clicking this link. <br>
        Share with us your comments, reviews and experience with the application. <br>
        See you next week with a different tutorial regarding a new technology. <br>
    </p>                                                                                                                                                                                                                  
    <p class=""leftTextAlign"" >Written by Damián Cardozo. Posted on 21/03/2019 </p>
</div>");
            EndContext();
        }
        #pragma warning restore 1998
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.ViewFeatures.IModelExpressionProvider ModelExpressionProvider { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IUrlHelper Url { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IViewComponentHelper Component { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IJsonHelper Json { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper<IndexModel> Html { get; private set; }
        public global::Microsoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary<IndexModel> ViewData => (global::Microsoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary<IndexModel>)PageContext?.ViewData;
        public IndexModel Model => ViewData.Model;
    }
}
#pragma warning restore 1591
