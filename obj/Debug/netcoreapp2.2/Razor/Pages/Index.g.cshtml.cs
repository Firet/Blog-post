#pragma checksum "C:\Users\Damian\Desktop\SW\ASP\Pages\Index.cshtml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "bca8be1dcbd0417b791403b78075dbbe7058613c"
// <auto-generated/>
#pragma warning disable 1591
[assembly: global::Microsoft.AspNetCore.Razor.Hosting.RazorCompiledItemAttribute(typeof(aplicacionASP.Pages.Pages_Index), @"mvc.1.0.razor-page", @"/Pages/Index.cshtml")]
[assembly:global::Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.RazorPageAttribute(@"/Pages/Index.cshtml", typeof(aplicacionASP.Pages.Pages_Index), null)]
namespace aplicacionASP.Pages
{
    #line hidden
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.AspNetCore.Mvc.Rendering;
    using Microsoft.AspNetCore.Mvc.ViewFeatures;
#line 1 "C:\Users\Damian\Desktop\SW\ASP\Pages\_ViewImports.cshtml"
using aplicacionASP;

#line default
#line hidden
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"bca8be1dcbd0417b791403b78075dbbe7058613c", @"/Pages/Index.cshtml")]
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"c17c9475b3f2470ab716b84fe96bf22a87969a9f", @"/Pages/_ViewImports.cshtml")]
    public class Pages_Index : global::Microsoft.AspNetCore.Mvc.RazorPages.Page
    {
        #pragma warning disable 1998
        public async override global::System.Threading.Tasks.Task ExecuteAsync()
        {
#line 3 "C:\Users\Damian\Desktop\SW\ASP\Pages\Index.cshtml"
  
    ViewData["Title"] = "Home page";

#line default
#line hidden
            BeginContext(71, 8250, true);
            WriteLiteral(@"
<div class=""text-center"">
    <h1 class=""display-4"">Turorial .Net ASP</h1>
    <!-- <p>Learn about <a href=""https://docs.microsoft.com/aspnet/core"">building Web apps with ASP.NET Core</a>.</p> -->
</div>


<h1>introduccion</h1>
<h1>razones por que usar .net core (y docker)</h1>
    <p>adios a las incopatilidades entre sistemas operativos</p>
    <p>mucho mas ligero y escalable</p>
    <p>tan seguro como una maquina virtual ((enrealida esto habla de docker, yo quiero convencer de usar.net))</p>
    <p>control de versiones ((esto habla de docker pero esto puede ser una buena razon para .net))</p>
    <p>concebido para trabajar en la nube</p>
<h1>BLA ...</h1>
    
    <p></p>
    <p></p>
<h1></h1>
    <p></p>
    <p></p>
    <p></p>
<h1></h1>
    <p></p>
    <p></p>
    <p></p>
<h1></h1>
    <p></p>
    <p></p>
    <p></p>


Guía fácil paso a paso de como aprender a usar .Net y Docker (Easiest way to get started - Your first .NET Core Docker app - Dockerize the .NET Core applicat");
            WriteLiteral(@"ion - La combinación de docker junto a .net core es muy potente para el desarrollo)
‎Escrito por: Damián Cardozo. Publicado el 21/03/2019 a las 17:00 hs
https://www.campusmvp.es/recursos/post/7-motivos-para-utilizar-Docker-en-general-y-con-ASPNET-Core-en-particular.aspx
https://docs.microsoft.com/en-us/dotnet/core/docker/docker-basics-dotnet-core
Hola comunidad IT cómo están? Antes que nada, queremos compartirles y celebrar con ustedes que llegamos al seguidor número 50 K! Sisis ya sé, no hacemos sorteos como un instagramer!
En el día de hoy les traemos una guía paso a paso (Súper fácil según nuestros colaboradores) para hacer una pagina de internet con ASP.net usando los containers de docker.
Que vamos a aprender hoy? Como crear un Dockerfile y un .NET Application y como “how to deploy your app into a Docker container”.
A su vez, para revertir los dichos sobre Docker, te traemos las características y beneficios para utilizar Docker con ASP.NET Core.
    • Docker te permite crear paquetes estándar que");
            WriteLiteral(@" incluyen todo lo necesario para que la aplicación funcione. Es decir, Docker instala todas las dependencias y servicios para que funcione en cualquier sistema operativo.
    • La aplicación Docker se ha convertido en un sistema de paquetes tan popular que lo tienen en cuenta todos los fabricantes y proveedores de sistemas operativos y de cloud.
    • Con Docker conseguís consistencia y garantizas que el contenido puesto en un contenedor se va a ejecutar en cualquier computadora. Si funciona en desarrollo, funcionará en producción porque con Docker son la misma cosa.
    • Docker es mucho más ligero y escalable que una máquina virtual porque solo utiliza los recursos que necesita en cada momento.
    • Otra de las ventajas de Docker es que puede utilizarse para unificar también los entornos de desarrollo y el flujo de trabajo en éstos. Es decir, ni siquiera tienes que instalar en tu equipo los SDKs de trabajo, ni los compiladores:
    • Con Docker, podes definir un entorno de trabajo basado en imágenes D");
            WriteLiteral(@"ocker para todo tu equipo de trabajo (SOs diferentes) y con esto, te aseguras que todos los miembros tienen lo mismo y todo va a funcionar igual.
    • Aunque Docker se creó en y para Linux, su uso en .NET y Windows no para de crecer y es cada vez mejor, ya que Microsoft trabaja muy de cerca con el equipo de Docker y su comunidad.
Ahora vamos a la acción! La “Guía paso a paso”: 
Como siempre, te presentamos los Pre-requisitos, recordá que es necesario tener un editor de texto y tener instalado un sistema operativo con arquitectura x64 o x86.
Bueno, comencemos!
Lo primero que vamos a hacer es instalar .NET Core 2.1 SDK (o alguna versión superior), para instalarlo vamos al siguiente link y cliqueamos,  como se ve en la imagen , en download .NET CORE SDK. Mientras, aprovecha y hacete un cafe aunque la descarga no va a tardar mucho.
Una vez instalado .NET Core podes corroborar que se haya instalado correctamente escribiendo en la consola:
$ dotnet
Si al escribir el comando y dando enter aparecen escritas ");
            WriteLiteral(@"las instrucciones para usar dotnet, todo anda genial.
Si no te aparecen las instrucciones, probá comentando en los foros de .NET o escribimos en esta nota para contactarte y ayudarte a crear la aplicación.
Después, creamos la carpeta donde quieras guardar la aplicación y volvemos a la consola para escribir los siguientes comandos:
$ dotnet new webApp -o myWebApp --no-https
$ cd myWebApp
¿Qué significan estos comandos?
    • dotnet new crea una nueva aplicación.
    • El parámetro webApp indica que tipo o modelo de aplicación se requiere, en este caso queremos una aplicación web. 
    • -o crea una carpeta llamada myWebApp donde va a guardarse tu aplicación.
    • el flag --no-https específica que no queremos activar https.
    • Por último, el comando cd myWebApp nos lleva hacía nuestra nueva carpeta.
Llegó el momento de correr la aplicación!
En la consola escribimos:
$ dotnet run
Abrí el navegador y en la barra de direcciones ingresá en http://localhost:5000
Vaaaamoss! Ya está funcionando la a");
            WriteLiteral(@"plicación! (imagen de festejo).
Si queres editar tu aplicación, podes aprender a usar razor en el siguiente link, para cambiar el formato, colores y más.

Dockerizar una aplicación ASP.net Core! (Dockerize the .NET Core application)
Como plus tambien vamos a dockerizar nuestra aplicacion.
Ahora que la aplicación está corriendo localmente es hora de ir un paso más adelante y correrla con docker. 
Dentro de la carpeta que creamos para la aplicación ASP vamos a crear un archivo que se va a llamar Dockerfile, este archivo no lleva ninguna extensión. Usando el editor de texto vamos a abrir el dockerfile y escribir lo siguiente:
FROM microsoft/dotnet:2.1-sdk
WORKDIR /app

# copy csproj and restore as distinct layers
COPY *.csproj ./
RUN dotnet restore

# copy and build everything else
COPY . ./
RUN dotnet publish -c Release -o out
ENTRYPOINT [""dotnet"", ""out/Hello.dll""]
Te estas preguntando que acabamos de hacer? Lo que escribimos en el archivo dockerfile contiene instruciones para que docker corra");
            WriteLiteral(@" la aplicación. 
Si querés interiorizarte en el significado de las instrucciones, mirá el siguiente link(chequear)
La primer instrucción tiene que ser FROM. Esta misma inicializa una nueva etapa de construcción y configura la imagen base para las siguientes instrucciones. 
La instrucción WORKDIR configura la carpeta en la que estamos trabajando. SI la carpeta no existe, es creada. 
La instrucción COPY copia nuevos archivos o carpetas desde la ruta de origen y los agrega al container de destino. Con esta instrucción estamos copiando los archivos en C# al container.
La instrucción RUN ejecuta cualquier comando de la imagen y hace un commit de los resultados. Corremos dotnet restore para obtener todas las dependencias que necesitamos.
El comando Dotnet publish compila la aplicación.
La instrucción ENTRYPOINT [“dotnet”, out/Hello.dll”] nos permite correr el container como un ejecutable.
Perfecto! Ahora tenemos un container que copia nuestra applicación y la ejecuta.
Builder y correr una aplicación ASP.ne");
            WriteLiteral(@"t
Ahora que terminamos con el dockerfile, docker va a crear nuestra aplicación y usar el container.
Escbiramos lo siguiente en la consola:
$ docker build -t dotnetapp-dev .
$ docker run –rm dotnetapp-dev Hello from Docker
Vas a ver algo similar a esta imagen PONER IMAGEN O NO 
como se puede ver por el resultado, ya esta todo andando. 
Podes escribir el comando docker run y ver en la consola “Hello world”
Felicitaciones! Has creado una aplicación ASP.NET y la has corrido con docker!
Here are some next steps you can take:
Introduction to .NET Docker Images Video
Visual Studio, Docker & Azure Container Instances better together!
Docker for Azure Quickstarts
Deploy your app on Docker for Azure
Bueno, esto fue todo por hoy. Nos vamos despidiendo!
Recordá valorarnos el tutorial para poder seguir haciendo crecer nuestra comunidad y nos encontramos en la próxima publicación!
Debajo, podes dejarnos tus comentarios y compartirnos tu experiencia en la creación de tu aplicación! Te estamos leyendo! (carit");
            WriteLiteral("a señalando/ observando).\r\nNos vemos en el siguiente post!");
            EndContext();
        }
        #pragma warning restore 1998
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.ViewFeatures.IModelExpressionProvider ModelExpressionProvider { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IUrlHelper Url { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IViewComponentHelper Component { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IJsonHelper Json { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper<IndexModel> Html { get; private set; }
        public global::Microsoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary<IndexModel> ViewData => (global::Microsoft.AspNetCore.Mvc.ViewFeatures.ViewDataDictionary<IndexModel>)PageContext?.ViewData;
        public IndexModel Model => ViewData.Model;
    }
}
#pragma warning restore 1591
